import nemo;

export {
    translateZ3(triple: HoareTriple, formulas: [Condition]) -> Maybe<string>;
}

typeZ3(type: Type) -> string {
    switch (type) {
        IntType(): "Int";
        ArrayType(inner): "(Array " + typeZ3(inner) + " Int)"; 
    }
}

declZ3(decl: Declaration) -> string {
    "(declare-const " + decl.variable + " " + typeZ3(decl.type) + ")"
}

exprZ3(expr: Expr) -> string {
    binop = \lhs, sign, rhs -> {
        "(" + sign + " " + exprZ3(lhs) + " " + exprZ3(rhs) + ")"
    };
    
    switch (expr) {
        Add(lhs, rhs): binop(lhs, "+", rhs);
        Sub(lhs, rhs): binop(lhs, "-", rhs);
        Mul(lhs, rhs): binop(lhs, "*", rhs);
        Div(lhs, rhs): binop(lhs, "/", rhs);
        Neg(inner): exprZ3(Sub(Int(0), inner));
        Int(value): i2s(value);
        Var(name): name;
        Update(array, index, value): {
            "(store " + exprZ3(array) + " " + exprZ3(index) + " " + exprZ3(value) + ")"
        };
        Apply(array, index): {
            "(select " + exprZ3(array) + " " + exprZ3(index) + ")"
        };
        Array(values): {
            "[" + strGlue(map(values, exprZ3), ", ") + "]"
        };
    }
}

formulaZ3(formula: Condition) -> string {
    comparison = \lhs, sign, rhs -> {
        "(" + sign + " " + exprZ3(lhs) + " " + exprZ3(rhs) + ")"
    };

    binary = \lhs, sign, rhs -> {
        "(" + sign + " " + formulaZ3(lhs) + " " + formulaZ3(rhs) + ")"
    };
    
    switch (formula) {
        True(): "true";
        False(): "false";
        And(lhs, rhs): binary(lhs, "and", rhs);
        Or(lhs, rhs): binary(lhs, "or", rhs);
        Implies(lhs, rhs): binary(lhs, "=>", rhs);
        Not(inner): "(not " + formulaZ3(inner) + ")";
        Comparison(lhs, relation, rhs): switch (relation) {
            Equal(): comparison(lhs, "=", rhs);
            NotEqual(): "(not " + comparison(lhs, "=", rhs) + ")";
            Less(): comparison(lhs, "<", rhs);
            LessOrEqual(): comparison(lhs, "<=", rhs);
            Greater(): comparison(lhs, ">", rhs);
            GreaterOrEqual(): comparison(lhs, ">=", rhs);
        }
    }
}

translateZ3(triple: HoareTriple, formulas: [Condition]) -> Maybe<string> {
    maybeMap(
        inferTypes(triple.program.decls, formulas),
        \types -> strGlue(
            concat3(
                map(
                    tree2pairs(types),
                    \pair -> declZ3(Declaration(pair.first, pair.second))
                ),
                map(
                    formulas,
                    \formula -> "(assert " + formulaZ3(Not(formula)) + ")"
                ),
                ["(check-sat)"]
            ),
            "\n"
        )
    )
}

// Merge Trees, return None() if any keys match but values are not equal
maybeMerge(first: Tree<?, ??>, second: Tree<?, ??>) -> Maybe<Tree<?, ??>> {
    foldTree(
        second,
        Some(first),
        \key, value, result -> {
            maybeBind(
                result,
                \tree -> {
                    switch (lookupTree(tree, key)) {
                        Some(looked_up): if (looked_up == value) {
                            Some(tree)
                        } else {
                            None()
                        };

                        None(): Some(setTree(tree, key, value));
                    }
                }
            )
        }
    )
}

inferTypes(decls: [Declaration], formulas: [Condition]) -> Maybe<Tree<string, Type>> {
    declared = fold(
        decls,
        makeTree(),
        \types, decl -> setTree(types, decl.variable, decl.type)
    );

    foldM(
        formulas,
        declared,
        \types, formula -> maybeBind(
            inferTypesCond(declared, formula),
            \formula_types -> maybeMerge(types, formula_types)
        )
    )
}

inferTypesCond(decls: Tree<string, Type>, formula: Condition) -> Maybe<Tree<string, Type>> {
    switch (formula) {
        True(): Some(makeTree());
        False(): Some(makeTree());
        And(lhs, rhs):
        Or(lhs, rhs):
        Implies(lhs, rhs):
        Not(inner):
        Comparison(lhs, relation, rhs):
    }
}

inferTypesExpr(decls: Tree<string, Type>, expr: Expr, suggested: Type) -> Maybe<Tree<string, Type>> {

}