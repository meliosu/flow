import nemo;

export {
    translateZ3(triple: HoareTriple, formulas: [Condition]) -> Maybe<string>;
}

typeZ3(type: Type) -> string {
    switch (type) {
        IntType(): "Int";
        ArrayType(base, index): "(Array " + typeZ3(base) + " " + typeZ3(index) + ")"; 
    }
}

declZ3(decl: Declaration) -> string {
    "(declare-const " + decl.variable + " " + typeZ3(decl.type) + ")"
}

formulaDefinitionZ3(formula: Formula, types: Tree<string, Type>) -> string {
    "(define-fun " + formula.name + " (" +
        strGlue(
            map(
                formula.params,
                \param -> "(" + param + " " + typeZ3(either(lookupTree(types, param), IntType()))+  ")"
            ),

            " "
        )
    + ")" + " Bool " + formulaZ3(formula.body) + ")"
}

functionDefinitionZ3(function: Function, types: Tree<string, Type>) -> string {
    "(define-fun " + function.name + " (" +
        strGlue(
            map(
                function.params,
                \param -> "(" + param + " " + typeZ3(either(lookupTree(types, param), IntType()))+  ")"
            ),

            " "
        )
    + ")" + " Int " + exprZ3(function.body) + ")"
}

exprZ3(expr: Expr) -> string {
    binop = \lhs, sign, rhs -> {
        "(" + sign + " " + exprZ3(lhs) + " " + exprZ3(rhs) + ")"
    };
    
    switch (expr) {
        Add(lhs, rhs): binop(lhs, "+", rhs);
        Sub(lhs, rhs): binop(lhs, "-", rhs);
        Mul(lhs, rhs): binop(lhs, "*", rhs);
        Div(lhs, rhs): binop(lhs, "/", rhs);
        Neg(inner): exprZ3(Sub(Int(0), inner));
        Int(value): i2s(value);
        Var(name): name;
        Update(array, index, value): {
            "(store " + exprZ3(array) + " " + exprZ3(index) + " " + exprZ3(value) + ")"
        };
        Apply(array, index): {
            "(select " + exprZ3(array) + " " + exprZ3(index) + ")"
        };
        Array(values): {
            "[" + strGlue(map(values, exprZ3), ", ") + "]"
        };
        FunctionCall(symbol, args): {
            "(" + symbol + " " + strGlue(map(args, exprZ3), " ") + ")"
        };
    }
}

formulaZ3(formula: Condition) -> string {
    comparison = \lhs, sign, rhs -> {
        "(" + sign + " " + exprZ3(lhs) + " " + exprZ3(rhs) + ")"
    };

    binary = \lhs, sign, rhs -> {
        "(" + sign + " " + formulaZ3(lhs) + " " + formulaZ3(rhs) + ")"
    };

    quantor = \func, var, body -> {
        "(" + func + " ((" + var + " Int))" + formulaZ3(body) + ")"
    };
    
    switch (formula) {
        True(): "true";
        False(): "false";
        And(lhs, rhs): binary(lhs, "and", rhs);
        Or(lhs, rhs): binary(lhs, "or", rhs);
        Implies(lhs, rhs): binary(lhs, "=>", rhs);
        Iff(lhs, rhs): binary(lhs, "=", rhs);
        Not(inner): "(not " + formulaZ3(inner) + ")";
        Comparison(lhs, relation, rhs): switch (relation) {
            Equal(): comparison(lhs, "=", rhs);
            NotEqual(): "(not " + comparison(lhs, "=", rhs) + ")";
            Less(): comparison(lhs, "<", rhs);
            LessOrEqual(): comparison(lhs, "<=", rhs);
            Greater(): comparison(lhs, ">", rhs);
            GreaterOrEqual(): comparison(lhs, ">=", rhs);
        }

        Call(symbol, args): {
            "(" + symbol + " " + strGlue(map(args, exprZ3), " ") + ")"
        }

        Exists(var, body): formulaZ3(
            Not(Forall(var, Not(body)))
        );

        Forall(var, body): quantor("forall", var, body);
    }
}

translateZ3(triple: HoareTriple, formulas: [Condition]) -> Maybe<string> {
    maybeMap(
        inferTypes(triple.program.decls, formulas),
        \types -> strGlue(
            concatA([
                map(
                    tree2pairs(types),
                    \pair -> declZ3(Declaration(pair.first, pair.second))
                ),
                map(
                    triple.formulas,
                    \formula -> formulaDefinitionZ3(formula, types)
                ),
                map(
                    triple.functions,
                    \function -> functionDefinitionZ3(function, types),
                ),
                map(
                    formulas,
                    \formula -> "(assert " + formulaZ3(Not(formula)) + ")"
                ),
                ["(check-sat)"]
            ]),
            "\n"
        )
    )
}

// Merge Trees, return None() if any keys match but values are not equal
maybeMerge(first: Tree<?, ??>, second: Tree<?, ??>) -> Maybe<Tree<?, ??>> {
    foldTree(
        second,
        Some(first),
        \key, value, result -> {
            maybeBind(
                result,
                \tree -> {
                    switch (lookupTree(tree, key)) {
                        Some(looked_up): if (looked_up == value) {
                            Some(tree)
                        } else {
                            None()
                        };

                        None(): Some(setTree(tree, key, value));
                    }
                }
            )
        }
    )
}

inferTypes(decls: [Declaration], formulas: [Condition]) -> Maybe<Tree<string, Type>> {
    declared = fold(
        decls,
        makeTree(),
        \types, decl -> setTree(types, decl.variable, decl.type)
    );

    foldM(
        formulas,
        declared,
        \types, formula -> maybeBind(
            inferTypesCond(declared, formula),
            \formula_types -> maybeMerge(types, formula_types)
        )
    )
}

inferTypesCond(decls: Tree<string, Type>, formula: Condition) -> Maybe<Tree<string, Type>> {
    binop = \lhs, rhs -> {
        maybeBind2(
            \l, r -> maybeMerge(l, r)
        )(
            inferTypesCond(decls, lhs),
            inferTypesCond(decls, rhs)
        )
    };

    switch (formula) {
        True(): Some(makeTree());
        False(): Some(makeTree());
        And(lhs, rhs): binop(lhs, rhs);
        Or(lhs, rhs): binop(lhs, rhs);
        Implies(lhs, rhs): binop(lhs, rhs);
        Not(inner): inferTypesCond(decls, inner);
        Comparison(lhs, relation, rhs): maybeBind2(
            \l, r -> maybeMerge(l, r)
        )(
            inferTypesExpr(decls, lhs, IntType()), 
            inferTypesExpr(decls, rhs, IntType())
        );

        default: Some(makeTree());
    }
}

inferTypesExpr(decls: Tree<string, Type>, expr: Expr, suggested: Type) -> Maybe<Tree<string, Type>> {
    binop = \lhs, rhs -> {
        if (suggested == IntType()) {
            maybeBind2(
                \l, r -> maybeMerge(l, r)
            )(
                inferTypesExpr(decls, lhs, IntType()), 
                inferTypesExpr(decls, rhs, IntType())
            )
        } else {
            None()
        }
    };

    unary = \e -> {
        if (suggested == IntType()) {
            inferTypesExpr(decls, e, IntType())
        } else {
            None()
        }
    };
    
    switch (expr) {
        Add(lhs, rhs): binop(lhs, rhs);
        Sub(lhs, rhs): binop(lhs, rhs);
        Mul(lhs, rhs): binop(lhs, rhs);
        Div(lhs, rhs): binop(lhs, rhs);
        Neg(inner): unary(inner);
        Int(value): Some(makeTree());
        Var(name): Some(makeTree1(name, suggested));
        Update(array, index, value): switch (suggested) {
            ArrayType(base_ty, index_ty): {
                maybeBind(
                    inferTypesExpr(decls, array, suggested),
                    \array_types -> maybeBind(
                        inferTypesExpr(decls, index, index_ty),
                        \index_types -> maybeBind(
                            inferTypesExpr(decls, value, base_ty),
                            \value_types -> maybeBind(
                                maybeMerge(array_types, index_types),
                                \merged_types -> maybeMerge(
                                    merged_types, value_types
                                )
                            )
                        )
                    )
                )
            };

            IntType(): None();
        };

        Apply(array, index): maybeBind(
            evalType(index, decls),
            \index_ty -> {
                maybeBind2(
                    \a, b -> maybeMerge(a, b),
                )(
                    inferTypesExpr(decls, array, ArrayType(suggested, index_ty)),
                    inferTypesExpr(decls, index, index_ty)
                )
            }
        );

        Array(values): switch (suggested) {
            ArrayType(base, index): foldM(
                values,
                makeTree(),
                \tree, value -> {
                    maybeBind(
                        inferTypesExpr(decls, value, base),
                        \tys -> maybeMerge(tree, tys)
                    )
                }
            );

            IntType(): None();
        };

        default: Some(makeTree());
    }
}