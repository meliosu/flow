hoare_triple = ws declaration*:decls 
  ws function*:functions 
  ws formula*:formulas 
  ws "{" ws condition:pre ws "}" 
  ws body:body 
  ws "{" ws condition:post ws "}" 
  ws 
  { buildTriple(
    :decls,
    :functions,
    :formulas,
    :pre,
    :body,
    :post
  ) }; 

function = ws "function" ws name$name ws "(" ws ident:first ws _param*:other ws ")" ws expr:b ws { buildFunction($name, :first, :other, :b) };

program = ws declaration*:decls ws body:body ws { Program(:decls, :body) };

ident = ws name$n ws { $n };

formula = ws "formula" ws ident:fname ws "(" ws ident:first ws _param*:other ws ")" ws condition:b ws 
  { buildFormula(:fname, :first, :other, :b) }; 

_param = ws "," ws name$n ws { $n }; 

expr = function_call | add | sub | mul | div | neg | int | apply | update | array | var;

add = ws "(" ws expr:lhs ws "+" ws expr:rhs ws ")" ws { Add(:lhs, :rhs) };
sub = ws "(" ws expr:lhs ws "-" ws expr:rhs ws ")" ws { Sub(:lhs, :rhs) };
mul = ws "(" ws expr:lhs ws "*" ws expr:rhs ws ")" ws { Mul(:lhs, :rhs) };
div = ws "(" ws expr:lhs ws "/" ws expr:rhs ws ")" ws { Div(:lhs, :rhs) };
neg = ws "-" ws expr:inner ws { Neg(:inner) };
int = integer:integer { Int(:integer) };
var = name$name { Var($name) };
apply = ws "APP" ws "(" ws expr:array ws "," ws expr:index ws ")" ws { Apply(:array, :index) };
update = ws "UPD" ws "(" ws expr:array ws "," ws expr:index ws "," ws expr:value ws ")" ws { Update(:array, :index, :value) };
array = ws "[" ws expr:first ("," ws expr)*:other ws "]" ws { buildArray(:first, :other) };
function_call = ws ident:n ws "(" ws expr:first ws _arg*:other ws ")" ws { buildFunctionCall(:n, :first, :other) };

type = int_type | array_type;

int_type = ws "INT" ws  { IntType() };
array_type = ws int_type:int ws "ARRAY" ws "OF" ws type:type  ws { ArrayType(:type, :int) };

relation = 
      "=" { Equal() }
    | "!=" { NotEqual() }
    | "<=" { LessOrEqual() }
    | "<"  { Less() }
    | ">=" { GreaterOrEqual() }
    | ">"  { Greater() };

condition =  exists | forall  | iff | and | or | implies | not | comparison | true | false | call;

exists = ws "E" ws name$var ws "." ws condition:body ws { Exists($var, :body) };
forall = ws "A" ws name$var ws "." ws condition:body ws { Forall($var, :body) };
true = ws "TRUE" ws { True() };
false = ws "FALSE" ws { False() }; 
comparison = ws "(" ws expr:lhs ws relation:relation ws expr:rhs ws ")" ws { Comparison(:lhs, :relation, :rhs) };
and = ws "(" ws condition:lhs ws ("&&" | "&" | "∧") ws condition:rhs ws ")" ws { And(:lhs, :rhs) };
or = ws "(" ws condition:lhs ws ("||" | "|" | "∨") ws condition:rhs ws ")" ws { Or(:lhs, :rhs) };
implies = ws "(" ws condition:lhs ws "->" ws condition:rhs ws ")" ws { Implies(:lhs, :rhs) };
not = ws "!" ws condition:condition ws { Not(:condition) };
call = ws ident:n ws "(" ws expr:first ws _arg*:other ws ")" ws { buildCall(:n, :first, :other) };
iff = ws "(" ws condition:lhs ws "<->" ws condition:rhs ws ")" ws { Iff(:lhs, :rhs) };

_arg = ws "," ws expr:arg ws { :arg };

declaration = ws "VAR" ws name$name ws ":" ws type:type ws ";" ws { Declaration($name, :type) };

body = assignment | test | iteration | sequence | selection;
assignment = ws name$name ws ":=" ws expr:expr ws { Assignment($name, :expr) };
test =  ws condition:condition ws "?" ws { Test(:condition) };
_sequence = ws body:body ws ";" ws { :body }; 
sequence = ws "{" ws _sequence*:bodies ws "}" ws { Sequence(:bodies) };
selection =  ws "{" ws body:first (ws "U" ws body)+:other ws "}" ws { buildSelection(:first, :other) };
iteration = ws "{" ws condition:inv ws "}" ws "{" _sequence*:bodies ws "}" ws "*"  ws { buildIteration(:bodies, :inv) };


ws = (" " | "\t" | "\r" | "\n")*;
integer = ('0'-'9')+$integer { s2i($integer) };
name = ('a'-'z' | 'A'-'Z') ('a'-'z' | 'A'-'Z' | '0'-'9')*;