import nemo;
import ds/tree;
import ds/set;
import ds/arrayutils;

export {
    translateProgram(program: Program) -> VMProgram;
    vmProgramRun(program: VMProgram, limit: int) -> void;
    vmProgram2s(program: VMProgram) -> string;

    VMInsn ::= VMAssign, VMIf;
        VMAssign(label: int, var: string, expr: Expr, next: [int]);
        VMIf(label: int, cond: Condition, then: [int], or_else: [int]);

    VMValue ::= VMInt, VMArray;
        VMInt(value: int);
        VMArray(values: [VMValue]);

    VMState(pos: int, values: Tree<string, VMValue>);
    VMProgram(decls: [Declaration], insns: [VMInsn]);
}

vmProgramRun(program: VMProgram, limit: int) -> void {
    start = VMState(0, makeTree());

    switch (vmRun(program, start, limit)) {
        Some(states): {
            iterSet(
                states,
                \state -> println(state2s(state) + "\n\n")
            );
        };

        None(): {
            println("error running VM");
        };
    }
}

translateProgram(program: Program) -> VMProgram {
    VMProgram(program.decls, cleanEnds(translateBody(program.body)))
}

translateBody(b: Body) -> [VMInsn] {
    switch (b) {
        Assignment(variable, expr): {
            [VMAssign(0, variable, expr, [-1])]
        }

        Test(cond): {
            [VMIf(0, cond, [-1], [])]
        }

        Sequence(bodies): {
            fold(
                map(bodies, \body -> translateBody(body)),
                [],
                \result, body -> {
                    if (length(result) == 0) {
                        body
                    } else {
                        shift = maxLabel(result);
                        shifted = shiftLabels(body, shift);
                        connected = connectLabels(result, shift);
                        concat(connected, shifted);
                    }
                }
            )
        }

        Selection(bodies): {
            fold(
                map(bodies, \body -> translateBody(body)),
                [],
                \result, body -> {
                    shift = maxLabel(result);
                    shifted = shiftNonZeroLabels(body, shift);
                    concat(result, shifted);
                }
            )
        }

        Iteration(inner): {
            translated = translateBody(inner);

            // TODO: change
            if_insn = VMIf(0, True(), [1, -1], []);
            shifted = shiftLabels(translated, 1);
            connected = connectLabels(shifted, 0);
            concat([if_insn], connected);
        }
    }
}

insnLabel(insn: VMInsn) -> int {
    switch (insn) {
        VMAssign(label, _var, _expr, _goto): label;
        VMIf(label, _cond, _then, _or_else): label;
    }
}

maxLabel(insns: [VMInsn]) -> int {
    maxAFnDef(insns, \insn -> insnLabel(insn), 0) + 1
}

cleanEnds(insns: [VMInsn]) -> [VMInsn] {
    removeNegatives = \array -> filter(array, \a -> a >= 0);
    
    map(
        insns,
        \insn -> switch (insn) {
            VMAssign(a, b, c, goto): {
                VMAssign(a, b, c, removeNegatives(goto));
            };

            VMIf(a, b, then, or_else): {
                VMIf(a, b, removeNegatives(then), removeNegatives(or_else));
            };
        }
    )
}

shiftLabels(insns: [VMInsn], shift: int) -> [VMInsn] {
    doShift = \array -> {
        map(array, \a -> if (a >= 0) { a + shift } else { a })
    };
    
    map(
        insns,
        \insn -> switch (insn) {
            VMAssign(label, var, expr, goto): {
                VMAssign(label + shift, var, expr, doShift(goto))
            };

            VMIf(label, cond, then, or_else): {
                VMIf(label + shift, cond, doShift(then), doShift(or_else))
            };
        }
    )
}

shiftNonZeroLabels(insns: [VMInsn], shift: int) -> [VMInsn] {
    shiftJumps = \array -> {
        map(array, \a -> if (a > 0) { a + shift } else { a })
    };

    shiftLabel = \label -> if (label > 0) { label + shift } else { label };

    map(
        insns,
        \insn -> switch (insn) {
            VMAssign(label, var, expr, goto): {
                VMAssign(shiftLabel(label), var, expr, shiftJumps(goto))
            };

            VMIf(label, cond, then, or_else): {
                VMIf(shiftLabel(label), cond, shiftJumps(then), shiftJumps(or_else))
            };
        }
    )
}

connectLabels(insns: [VMInsn], shift: int) -> [VMInsn] {
    replaceEnds = \array -> map(array, \a -> if (a == -1) { shift } else { a });
    
    map(
        insns,
        \insn -> switch (insn) {
            VMAssign(label, var, expr, goto): {
                VMAssign(label, var, expr, replaceEnds(goto));
            };

            VMIf(label, cond, then, or_else): {
                VMIf(label, cond, replaceEnds(then), replaceEnds(or_else));
            };
        }
    )
}

insnsWithLabel(insns: [VMInsn], label: int) -> [VMInsn] {
    filter(insns, \insn -> insnLabel(insn) == label)
}

vmRun(program: VMProgram, state: VMState, limit: int) -> Maybe<Set<VMState>> {
    if (limit == 0) {
        Some(makeSet1(state));
    } else {
        foldM(
            insnsWithLabel(program.insns, state.pos),
            makeSet(),
            \S, insn -> {
                newS = switch (insn) {
                    VMAssign(_, var, expr, next): {
                        maybeBind(
                            evalExpr(expr, state.values),
                            \expr_value -> {
                                if (length(next) == 0) {
                                    Some(makeSet1(VMState(state.pos, setTree(state.values, var, expr_value))));
                                } else {
                                    foldM(
                                        next,
                                        makeSet(),
                                        \set, next_pos -> {
                                            next_state = VMState(
                                                next_pos,
                                                setTree(state.values, var, expr_value)
                                            );

                                            maybeMap(
                                                vmRun(program, next_state, limit - 1),
                                                \next_set -> mergeSets(set, next_set)
                                            );
                                        }
                                    );
                                }
                            }
                        )
                    };

                    VMIf(_, cond, then, or_else): {
                        maybeBind(
                            evalCondition(cond, state.values),
                            \cond_value -> {
                                jumps = if (cond_value) { then } else { or_else };

                                if (length(jumps) == 0) {
                                    Some(makeSet1(state));
                                } else {
                                    foldM(
                                        jumps,
                                        makeSet(),
                                        \set, next_pos -> maybeMap(
                                            vmRun(program, VMState(next_pos, state.values), limit - 1),
                                            \next_set -> mergeSets(set, next_set)
                                        )
                                    );
                                }
                            }
                        )
                    };
                };

                maybeMap(
                    newS,
                    \idk -> mergeSets(S, idk)
                );
            }
        );        
    }
}

evalExpr(expr: Expr, values: Tree<string, VMValue>) -> Maybe<VMValue> {
    evalBinop = \lhs, rhs, op -> {
        maybeBind2(
            \left, right -> {
                switch (left) {
                    VMInt(left_value): {
                        switch (right) {
                            VMInt(right_value): Some(VMInt(op(left_value, right_value)));
                            VMArray(_): None();
                        }
                    };

                    VMArray(_): None();
                }
            }
        )(evalExpr(lhs, values), evalExpr(rhs, values))
    };

    evalArray = \array -> {
        foldM(
            array,
            [],
            \arr, e -> {
                switch (evalExpr(e, values)) {
                    Some(value): Some(arrayPush(arr, value));
                    None(): None();
                }
            }
        )
    };

    evalUpdate = \array, index, value -> {
        maybeBind(
            evalExpr(array, values),
            \arr -> maybeBind(
                evalExpr(index, values),
                \ind -> maybeBind(
                    evalExpr(value, values),
                    \val -> {
                        switch (arr) {
                            VMArray(arr_values): {
                                // TODO: typecheck val
                                
                                switch (ind) {
                                    VMInt(ind_value): Some(VMArray(insertArray(arr_values, ind_value, val)));
                                    VMArray(_): None();
                                }
                            };

                            VMInt(_): None();
                        }
                    }
                )
            )
        )
    };

    evalApply = \array, index -> {
        maybeBind2(
            \arr, ind -> {
                switch (arr) {
                    VMArray(array_values): {
                        switch (ind) {
                            VMInt(ind_value): Some(array_values[ind_value])
                            VMArray(_): None();
                        }
                    };

                    VMInt(_): None();
                }
            }
        )(evalExpr(array, values), evalExpr(index, values))
    };

    evalNeg = \inner -> {
        maybeBind(
            evalExpr(inner, values),
            \v -> {
                switch (v) {
                    VMInt(v_value): Some(VMInt(-v_value));
                    VMArray(_): None();
                }
            }
        )
    };

    switch (expr) {
        Add(lhs, rhs): evalBinop(lhs, rhs, \a, b -> a + b);
        Sub(lhs, rhs): evalBinop(lhs, rhs, \a, b -> a - b);
        Mul(lhs, rhs): evalBinop(lhs, rhs, \a, b -> a * b);
        Div(lhs, rhs): evalBinop(lhs, rhs, \a, b -> a / b);
        Neg(inner): evalNeg(inner);
        Int(value): Some(VMInt(value));
        Var(name): lookupTree(values, name);
        Array(array): maybeMap(evalArray(array), \arr -> VMArray(arr));
        Update(array, index, value): evalUpdate(array, index, value);
        Apply(array, index): evalApply(array, index);
    }
}

evalCondition(cond: Condition, values: Tree<string, VMValue>) -> Maybe<bool> {
    evalBinCond = \lhs, rhs, combine -> {
        maybeMap2(
            \left, right -> combine(left, right)
        )(evalCondition(lhs, values), evalCondition(rhs, values));
    };

    evalComparison = \lhs, relation, rhs -> {
        maybeBind2(
            \left, right -> {
                switch (left) {
                    VMInt(left_value): {
                        switch (right) {
                            VMInt(right_value): {
                                cmp = switch (relation) {
                                    Equal(): left_value == right_value;
                                    NotEqual(): left_value != right_value;
                                    Less(): left_value < right_value;
                                    LessOrEqual(): left_value <= right_value;
                                    Greater(): left_value > right_value;
                                    GreaterOrEqual(): left_value >= right_value;
                                };

                                Some(cmp);
                            };

                            VMArray(_): None();
                        }
                    };

                    VMArray(_): None();
                }
            }
        )(evalExpr(lhs, values), evalExpr(rhs, values));
    };
    
    switch (cond) {
        True(): Some(true);
        False(): Some(false);
        And(lhs, rhs): evalBinCond(lhs, rhs, \a, b -> a && b);
        Or(lhs, rhs): evalBinCond(lhs, rhs, \a, b -> a || b);
        Not(inner): maybeMap(evalCondition(inner, values), \a -> !a);
        Comparison(lhs, relation, rhs): evalComparison(lhs, relation, rhs);
    }
}

insn2s(insn: VMInsn) -> string {
    jumps2s = \jumps -> {
        "{" + concatStrings(interleave(map(jumps, \j -> i2s(j)), ", ")) + "}";
    };
    
    switch (insn) {
        VMAssign(label, var, expr, next): {
            i2s(label) + ": " + var + " := " + expr2s(expr) + " goto " + jumps2s(next);
        }

        VMIf(label, cond, then, or_else): {
            i2s(label) + ": " + "if(" + cond2s(cond) + ") then " + jumps2s(then) + " else " + jumps2s(or_else);
        }
    }
}

vmProgram2s(program: VMProgram) -> string {
    concatStrings(map(program.insns, \insn -> insn2s(insn) + "\n"))
}

value2s(value: VMValue) -> string {
    switch (value) {
        VMInt(v): i2s(v);
        VMArray(array): {
            inner = concatStrings(
                interleave(map(array, \v -> value2s(v)), ", ")
            );

            "[" + inner + "]";
        }
    }
}

state2s(state: VMState) -> string {
    header = "[ON LABEL " + i2s(state.pos) + "]\n";
    values = concatStrings(
        foldTree(
            state.values,
            [],
            \variable, value, result -> {
                concat(
                    result,
                    [variable + " : " + value2s(value) + "\n"]
                )
            }
        )
    );

    header + values
}