import lingo/pegcode/driver;
import ds/tree;
import ds/arrayutils;

export {
    parseAst(input: string) -> HoareTriple;
    isValidProgram(program: Program) -> bool;
    expr2s(expr: Expr) -> string;
    cond2s(cond: Condition) -> string; 
    evalType(expr: Expr, types: Tree<string, Type>) -> Maybe<Type>;

    Expr ::= Add, Sub, Mul, Div, Neg, Int, Var, Apply, Update, Array, FunctionCall;
        Add(lhs: Expr, rhs: Expr);
        Sub(lhs: Expr, rhs: Expr);
        Mul(lhs: Expr, rhs: Expr);
        Div(lhs: Expr, rhs: Expr);
        Neg(inner: Expr);
        Int(value: int);
        Var(name: string);
        Update(array: Expr, index: Expr, value: Expr);
        Apply(array: Expr, index: Expr);
        Array(values: [Expr]);
        FunctionCall(name: string, args: [Expr]);

    Type ::= IntType, ArrayType;
        IntType();
        ArrayType(base: Type, index: Type);

    Relation ::= Equal, NotEqual, Less, LessOrEqual, Greater, GreaterOrEqual;
        Equal();
        NotEqual();
        Less();
        LessOrEqual();
        Greater();
        GreaterOrEqual();

    Condition ::= True, False, And, Or, Implies, Not, Comparison, Call, Exists, Forall, Iff;
        True();
        False();
        And(lhs: Condition, rhs: Condition);
        Or(lhs: Condition, rhs: Condition);
        Implies(lhs: Condition, rhs: Condition);
        Iff(lhs: Condition, rhs: Condition);
        Not(cond: Condition);
        Comparison(lhs: Expr, relation: Relation, rhs: Expr);
        Call(symbol: string, args: [Expr]);
        Exists(variable: string, body: Condition);
        Forall(variable: string, body: Condition);

    Body ::= Assignment, Test, Sequence, Selection, Iteration;
        Assignment(variable: string, expr: Expr);
        Test(cond: Condition);
        Sequence(bodies: [Body]);
        Selection(bodies: [Body]);
        Iteration(body: Body, inv: Condition);

    Hueta(formulas: [Formula]);

    Declaration(variable: string, type: Type);
    Program(decls: [Declaration], body: Body);
    HoareTriple(functions: [Function], formulas: [Formula], pre: Condition, program: Program, post: Condition);
    Formula(name: string, params: [string], body: Condition);
    Function(name: string, params: [string], body: Expr);
}

parseAst(input: string) -> HoareTriple {
    parsic(
        compilePegGrammar("#include C:/Study/ThirdCourse/mtc/labs/nemo/nemo.lingo"),
        input,
        pegActions(
            [
                Pair("buildArray", \a -> Array(concat([a[0]], a[1]))),
                Pair("buildSelection", \a -> Selection(concat([a[0]], a[1]))),
                Pair("buildFormula", \a -> Formula( 
                    a[0],
                    concat([a[1]], a[2]),
                    a[3]
                )),
                Pair("buildFunction", \a -> Function( 
                    a[0],
                    concat([a[1]], a[2]),
                    a[3]
                )),
                Pair("buildCall", \a -> Call(
                    a[0],
                    concat([a[1]], a[2])
                )),
                Pair("buildFunctionCall", \a -> FunctionCall(
                    a[0],
                    concat([a[1]], a[2])
                )),
                Pair("buildIteration", \b -> {
                    if (length(b[0]) == 1) {
                        Iteration(b[0][0], b[1])
                    } else {
                        Iteration(Sequence(b[0]), b[1])
                    }
                }),
            ]
        )
    )
}

transformDeclarations(decls: [Declaration]) -> Maybe<Tree<string, Type>> {
    foldM(
        decls,
        makeTree(),
        \tree, decl -> {
            switch (lookupTree(tree, decl.variable)) {
                Some(type): {
                    println("conflicting type declarations for " + decl.variable);
                    None();
                };

                None(): {
                    Some(setTree(tree, decl.variable, decl.type));
                };
            }
        }
    )
}

isValidProgram(program: Program) -> bool {
    switch (transformDeclarations(program.decls)) {
        Some(types): isValidBody(program.body, types);
        None(): isValidBody(program.body, makeTree()) && false;
    }
}

isValidBody(body: Body, types: Tree<string, Type>) -> bool {
    isValidBodies = \bodies -> {
        fold(
            bodies,
            true,
            \valid, b -> valid && isValidBody(b, types)
        )
    };
    
    switch (body) {
        Assignment(variable, expr): isValidAssignment(Assignment(variable, expr), types);
        Test(condition): isValidCondition(condition, types);
        Iteration(inner, inv): isValidBody(inner, types);
        Selection(bodies): isValidBodies(bodies);
        Sequence(bodies): isValidBodies(bodies);
    }
}

isValidAssignment(assignment: Assignment, types: Tree<string, Type>) -> bool {
    ret = switch (lookupTree(types, assignment.variable)) {
        Some(var_type): {
            switch (evalType(assignment.expr, types)) {
                Some(expr_type): {
                    if (expr_type == var_type) {
                        true;
                    } else {
                        println("left side and right side of assignment have different types");
                        false;
                    }
                };

                None(): {
                    false;
                }
            }
        };

        None(): {
            println("can't find type for left side of assignment for variable " + assignment.variable);
            false;
        };
    };

    if (!ret) {
        println("error in assignment " + assignment2s(assignment));
    }

    ret
}

isValidCondition(condition: Condition, types: Tree<string, Type>) -> bool {
    isValidComparison = \lhs, rhs -> {
        either(maybeMap2(
            \left, right -> {
                if (left == IntType() && right == IntType()) {
                    true;
                } else {
                    println("comparison operands must be integers");
                    false;
                }
            }
        )(evalType(lhs, types), evalType(rhs, types)), false)
    };
    
    ret = switch (condition) {
        True(): true;
        False(): true;
        And(lhs, rhs): isValidCondition(lhs, types) && isValidCondition(rhs, types);
        Or(lhs, rhs): isValidCondition(lhs, types) && isValidCondition(rhs, types);
        Implies(lhs, rhs): isValidCondition(lhs, types) && isValidCondition(rhs, types);
        Not(cond): isValidCondition(cond, types);
        Comparison(lhs, _, rhs): isValidComparison(lhs, rhs);
        default: true;
    };

    if (!ret) {
        println("error in condition " + cond2s(condition));
    }

    ret
}

evalType(expr: Expr, types: Tree<string, Type>) -> Maybe<Type> {
    evalBinopType = \lhs, rhs -> {
        maybeBind2(
            \left, right -> {
                if (left == IntType() && right == IntType()) {
                    Some(IntType());
                } else {
                    // println("operand of a binary operation should have int type");
                    None();
                }
            }
        )(evalType(lhs, types), evalType(rhs, types))
    };

    evalArrayType = \values -> {
        maybeBind(
            evalType(values[0], types),
            \type -> {
                foldM(
                    values,
                    type,
                    \ty, e -> {
                        maybeBind(
                            evalType(e, types),
                            \e_ty -> {
                                if (e_ty == type) {
                                    Some(ArrayType(type, IntType()));
                                } else {
                                    None();
                                }
                            }
                        )
                    }
                )
            }
        )
    };

    evalUpdateType = \array, index, value -> {
        maybeBind(
            evalType(array, types),
            \array_ty -> maybeBind(
                evalType(index, types),
                \index_ty -> maybeBind(
                    evalType(value, types),
                    \value_ty -> {
                        switch (array_ty) {
                            ArrayType(base, __index): {
                                if (__index == index_ty) {
                                    if (base == value_ty) {
                                        Some(array_ty);
                                    } else {
                                        // println("array element type does not match value in upd");
                                        None();
                                    }
                                } else {
                                    // println("wrong array index type");
                                    None();
                                }
                            }

                            IntType(): {
                                // println("first argument to upd must be an array");
                                None();
                            }
                        }
                    }
                )
            )
        )
    };

    evalApplyType = \array, index -> {
        maybeBind(
            evalType(array, types),
            \array_ty -> maybeBind(
                evalType(index, types),
                \index_ty -> {
                    switch (array_ty) {
                        ArrayType(base, __index_ty): {
                            if (__index_ty == index_ty) {
                                Some(base)
                            } else {
                                // println("wrong index type");
                                None();
                            }
                        };

                        IntType(): {
                            // println("first argument to app must be an array");
                            None();
                        }
                    }
                }
            )
        )
    };

    evalNeg = \inner -> {
        maybeBind(
            evalType(inner, types),
            \type -> {
                switch (type) {
                    ArrayType(base, index): {
                        // println("can't negate an array");
                        None();
                    };

                    IntType(): Some(IntType());
                }  
            }
        )
    };
    
    ret = switch (expr) {
        Add(lhs, rhs): evalBinopType(lhs, rhs);
        Sub(lhs, rhs): evalBinopType(lhs, rhs);
        Mul(lhs, rhs): evalBinopType(lhs, rhs);
        Div(lhs, rhs): evalBinopType(lhs, rhs);
        Neg(inner): evalNeg(inner);
        Int(value): Some(IntType());
        Var(name): lookupTree(types, name);
        Array(values): evalArrayType(values);
        Apply(array, index): evalApplyType(array, index);
        Update(array, index, value): evalUpdateType(array, index, value);
        FunctionCall(symbol, args): {
            Some(IntType())
        };
    };

    switch (ret) {
        Some(r): Some(r);
        None(): {
            // println("error in expression " + expr2s(expr));
            None();
        }
    }
}

expr2s(expr: Expr) -> string {
    binop2s = \lhs, rhs, sign -> "(" + expr2s(lhs) + sign + expr2s(rhs) + ")";
    
    array2s = \array -> {
        inner = concatStrings(interleave(
            map(
                array,
                \e -> expr2s(e),
            ),

            ", "
        ));

        "[" + inner + "]"
    };

    update2s = \array, index, value -> {
        "upd(" + expr2s(array) + ", " + expr2s(index) + ", " + expr2s(value) + ")"
    };

    apply2s = \array, index -> {
        "app(" + expr2s(array) + ", " + expr2s(index) + ")"
    };
    
    switch (expr) {
        Add(lhs, rhs): binop2s(lhs, rhs, " + ");
        Sub(lhs, rhs): binop2s(lhs, rhs, " - ");
        Mul(lhs, rhs): binop2s(lhs, rhs, " * ");
        Div(lhs, rhs): binop2s(lhs, rhs, " / ");
        Neg(inner): "-" + expr2s(inner);
        Var(name): name;
        Int(value): i2s(value);
        Array(array): array2s(array);
        Update(array, index, value): update2s(array, index, value);
        Apply(array, index): apply2s(array, index);
        FunctionCall(symbol, args): {
            symbol + "(" + strGlue(map(args, expr2s), ", ") + ")"
        };
    }
}

relation2s(relation: Relation) -> string {
    switch (relation) {
        Equal(): "=";
        NotEqual(): "!=";
        Less(): "<";
        LessOrEqual(): "<=";
        Greater(): ">";
        GreaterOrEqual(): ">=";
    }
}

cond2s(cond: Condition) -> string {
    switch (cond) {
        True(): "true";
        False(): "false";
        And(lhs, rhs): "(" + cond2s(lhs) + " & " + cond2s(rhs) + ")";
        Or(lhs, rhs): "(" + cond2s(lhs) + " v " + cond2s(rhs) + ")";
        Implies(lhs, rhs): "(" + cond2s(lhs) + " -> " + cond2s(rhs) + ")";
        Iff(lhs, rhs): "(" + cond2s(lhs) + "<->" + cond2s(rhs) + ")";
        Not(inner): "!(" + cond2s(inner)+ ")";
        Comparison(lhs, relation, rhs): expr2s(lhs) + " " + relation2s(relation) + " " + expr2s(rhs);
        Call(symbol, args): {
            symbol + "(" + strGlue(map(args, expr2s), ", ") + ")"
        }

        Exists(var, body): {
            "E " + var + "." + cond2s(body)
        };

        Forall(var, body): {
            "A " + var + "." + cond2s(body)
        };
    }
}

assignment2s(assignment: Assignment) -> string {
    assignment.variable + " := " + expr2s(assignment.expr)
}

type2s(type: Type) -> string {
    switch (type) {
        IntType(): "INT";
        ArrayType(base, index): type2s(index) + " ARRAY OF " + type2s(base);
    }
}

declaration2s(declaration: Declaration) -> string {
    declaration.variable + type2s(declaration.type)
}