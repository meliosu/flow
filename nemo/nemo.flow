import lingo/pegcode/driver;
import ds/tree;
import ds/arrayutils;

export {
    parseAst(input: string) -> Program;
    isValidProgram(program: Program) -> bool;
    expr2s(expr: Expr) -> string;
    cond2s(cond: Condition) -> string; 

    Expr ::= Add, Sub, Mul, Div, Neg, Int, Var, Apply, Update, Array;
        Add(lhs: Expr, rhs: Expr);
        Sub(lhs: Expr, rhs: Expr);
        Mul(lhs: Expr, rhs: Expr);
        Div(lhs: Expr, rhs: Expr);
        Neg(inner: Expr);
        Int(value: int);
        Var(name: string);
        Update(array: Expr, index: Expr, value: Expr);
        Apply(array: Expr, index: Expr);
        Array(values: [Expr]);

    Type ::= IntType, ArrayType;
        IntType();
        ArrayType(type: Type);

    Relation ::= Equal, NotEqual, Less, LessOrEqual, Greater, GreaterOrEqual;
        Equal();
        NotEqual();
        Less();
        LessOrEqual();
        Greater();
        GreaterOrEqual();

    Condition ::= True, False, And, Or, Not, Comparison;
        True();
        False();
        And(lhs: Condition, rhs: Condition);
        Or(lhs: Condition, rhs: Condition);
        Not(cond: Condition);
        Comparison(lhs: Expr, relation: Relation, rhs: Expr);

    Body ::= Assignment, Test, Sequence, Selection, Iteration;
        Assignment(variable: string, expr: Expr);
        Test(cond: Condition);
        Sequence(bodies: [Body]);
        Selection(bodies: [Body]);
        Iteration(body: Body);

    Declaration(variable: string, type: Type);
    Program(decls: [Declaration], body: Body);
}

parseAst(input: string) -> Program {
    parsic(
        compilePegGrammar("#include C:/Study/ThirdCourse/mtc/labs/nemo/nemo.lingo"),
        input,
        pegActions(
            [
                Pair("buildArray", \a -> Array(concat([a[0]], a[1]))),
                Pair("buildSelection", \a -> Selection(concat([a[0]], a[1]))),
                Pair("buildIteration", \b -> {
                    if (length(b[0]) == 1) {
                        Iteration(b[0][0])
                    } else {
                        Iteration(Sequence(b[0]))
                    }
                }),
            ]
        )
    )
}

transformDeclarations(decls: [Declaration]) -> Maybe<Tree<string, Type>> {
    foldM(
        decls,
        makeTree(),
        \tree, decl -> {
            switch (lookupTree(tree, decl.variable)) {
                Some(type): {
                    println("conflicting type declarations for " + decl.variable);
                    None();
                };

                None(): {
                    Some(setTree(tree, decl.variable, decl.type));
                };
            }
        }
    )
}

isValidProgram(program: Program) -> bool {
    switch (transformDeclarations(program.decls)) {
        Some(types): isValidBody(program.body, types);
        None(): false;
    }
}

isValidBody(body: Body, types: Tree<string, Type>) -> bool {
    isValidBodies = \bodies -> {
        fold(
            bodies,
            true,
            \valid, b -> valid && isValidBody(b, types)
        )
    };
    
    switch (body) {
        Assignment(variable, expr): isValidAssignment(Assignment(variable, expr), types);
        Test(condition): isValidCondition(condition, types);
        Iteration(inner): isValidBody(inner, types);
        Selection(bodies): isValidBodies(bodies);
        Sequence(bodies): isValidBodies(bodies);
    }
}

isValidAssignment(assignment: Assignment, types: Tree<string, Type>) -> bool {
    ret = switch (lookupTree(types, assignment.variable)) {
        Some(var_type): {
            switch (evalType(assignment.expr, types)) {
                Some(expr_type): {
                    if (expr_type == var_type) {
                        true;
                    } else {
                        println("left side and right side of assignment have different types");
                        false;
                    }
                };

                None(): {
                    false;
                }
            }
        };

        None(): {
            println("can't find type for left side of assignment for variable " + assignment.variable);
            false;
        };
    };

    if (!ret) {
        println("error in assignment " + assignment2s(assignment));
    }

    ret
}

isValidCondition(condition: Condition, types: Tree<string, Type>) -> bool {
    isValidComparison = \lhs, rhs -> {
        either(maybeMap2(
            \left, right -> {
                if (left == IntType() && right == IntType()) {
                    true;
                } else {
                    println("comparison operands must be integers");
                    false;
                }
            }
        )(evalType(lhs, types), evalType(rhs, types)), false)
    };
    
    ret = switch (condition) {
        True(): true;
        False(): true;
        And(lhs, rhs): isValidCondition(lhs, types) && isValidCondition(rhs, types);
        Or(lhs, rhs): isValidCondition(lhs, types) && isValidCondition(rhs, types);
        Not(cond): isValidCondition(cond, types);
        Comparison(lhs, _, rhs): isValidComparison(lhs, rhs);
    };

    if (!ret) {
        println("error in condition " + cond2s(condition));
    }

    ret
}

evalType(expr: Expr, types: Tree<string, Type>) -> Maybe<Type> {
    evalBinopType = \lhs, rhs -> {
        maybeBind2(
            \left, right -> {
                if (left == IntType() && right == IntType()) {
                    Some(IntType());
                } else {
                    println("operand of a binary operation should have int type");
                    None();
                }
            }
        )(evalType(lhs, types), evalType(rhs, types))
    };

    evalArrayType = \values -> {
        maybeBind(
            evalType(values[0], types),
            \type -> {
                foldM(
                    values,
                    type,
                    \ty, e -> {
                        maybeBind(
                            evalType(e, types),
                            \e_ty -> {
                                if (e_ty == type) {
                                    Some(ArrayType(type));
                                } else {
                                    None();
                                }
                            }
                        )
                    }
                )
            }
        )
    };

    evalUpdateType = \array, index, value -> {
        maybeBind(
            evalType(array, types),
            \array_ty -> maybeBind(
                evalType(index, types),
                \index_ty -> maybeBind(
                    evalType(value, types),
                    \value_ty -> {
                        switch (array_ty) {
                            ArrayType(element_ty): {
                                switch (index_ty) {
                                    IntType(): {
                                        if (element_ty == value_ty) {
                                            Some(array_ty);
                                        } else {
                                            println("array element type does not match value in upd");
                                            None();
                                        }
                                    }

                                    ArrayType(_): {
                                        println("array index must be an integer");
                                        None();
                                    }
                                }
                            }

                            IntType(): {
                                println("first argument to upd must be an array");
                                None();
                            }
                        }
                    }
                )
            )
        )
    };

    evalApplyType = \array, index -> {
        maybeBind(
            evalType(array, types),
            \array_ty -> maybeBind(
                evalType(index, types),
                \index_ty -> {
                    switch (array_ty) {
                        ArrayType(value_ty): {
                            switch (index_ty) {
                                IntType(): Some(value_ty);
                                ArrayType(_): {
                                    println("array index must be an integer");
                                    None();
                                }
                            }
                        };

                        IntType(): {
                            println("first argument to app must be an array");
                            None();
                        }
                    }
                }
            )
        )
    };

    evalNeg = \inner -> {
        maybeBind(
            evalType(inner, types),
            \type -> {
                switch (type) {
                    ArrayType(_): {
                        println("can't negate an array");
                        None();
                    };

                    IntType(): Some(IntType());
                }  
            }
        )
    };
    
    ret = switch (expr) {
        Add(lhs, rhs): evalBinopType(lhs, rhs);
        Sub(lhs, rhs): evalBinopType(lhs, rhs);
        Mul(lhs, rhs): evalBinopType(lhs, rhs);
        Div(lhs, rhs): evalBinopType(lhs, rhs);
        Neg(inner): evalNeg(inner);
        Int(value): Some(IntType());
        Var(name): lookupTree(types, name);
        Array(values): evalArrayType(values);
        Apply(array, index): evalApplyType(array, index);
        Update(array, index, value): evalUpdateType(array, index, value);
    };

    switch (ret) {
        Some(r): Some(r);
        None(): {
            println("error in expression " + expr2s(expr));
            None();
        }
    }
}

expr2s(expr: Expr) -> string {
    binop2s = \lhs, rhs, sign -> "(" + expr2s(lhs) + sign + expr2s(rhs) + ")";
    
    array2s = \array -> {
        inner = concatStrings(interleave(
            map(
                array,
                \e -> expr2s(e),
            ),

            ", "
        ));

        "[" + inner + "]"
    };

    update2s = \array, index, value -> {
        "upd(" + expr2s(array) + ", " + expr2s(index) + ", " + expr2s(value) + ")"
    };

    apply2s = \array, index -> {
        "app(" + expr2s(array) + ", " + expr2s(index) + ")"
    };
    
    switch (expr) {
        Add(lhs, rhs): binop2s(lhs, rhs, "+");
        Sub(lhs, rhs): binop2s(lhs, rhs, "-");
        Mul(lhs, rhs): binop2s(lhs, rhs, "*");
        Div(lhs, rhs): binop2s(lhs, rhs, "/");
        Neg(inner): "-" + expr2s(inner);
        Var(name): name;
        Int(value): i2s(value);
        Array(array): array2s(array);
        Update(array, index, value): update2s(array, index, value);
        Apply(array, index): apply2s(array, index);
    }
}

relation2s(relation: Relation) -> string {
    switch (relation) {
        Equal(): "==";
        NotEqual(): "!=";
        Less(): "<";
        LessOrEqual(): "<=";
        Greater(): ">";
        GreaterOrEqual(): ">=0";
    }
}

cond2s(cond: Condition) -> string {
    switch (cond) {
        True(): "true";
        False(): "false";
        And(lhs, rhs): "(" + cond2s(lhs) + " && " + cond2s(rhs) + ")";
        Or(lhs, rhs): "(" + cond2s(lhs) + " || " + cond2s(rhs) + ")";
        Not(inner): "!" + cond2s(inner);
        Comparison(lhs, relation, rhs): expr2s(lhs) + " " + relation2s(relation) + " " + expr2s(rhs);
    }
}

assignment2s(assignment: Assignment) -> string {
    assignment.variable + " := " + expr2s(assignment.expr)
}

type2s(type: Type) -> string {
    switch (type) {
        IntType(): "int";
        ArrayType(inner): "[" + type2s(inner) + "]";
    }
}

declaration2s(declaration: Declaration) -> string {
    declaration.variable + type2s(declaration.type)
}