import runtime;
import lingo/pegcode/driver;
import ds/arrayutils;

Expr ::= Add, Sub, Mul, Div, Neg, Int, Var;
    Add(lhs: Expr, rhs: Expr);
    Sub(lhs: Expr, rhs: Expr);
    Mul(lhs: Expr, rhs: Expr);
    Div(lhs: Expr, rhs: Expr);
    Neg(expr: Expr);
    Int(value: int);
    Var(name: string);

// switch (expr) {
//     Add(lhs, rhs):
//     Sub(lhs, rhs):
//     Mul(lhs, rhs):
//     Div(lhs, rhs):
//     Neg(inner):
//     Int(value):
//     Var(name):
// }

MatchRule(before: Expr, after: Expr);

s2expr(str: string) -> Expr {
    grammar = compilePegGrammar("#include grammar.lingo");
    parsic(grammar, str, defaultPegActions);
}

expr2s(expr: Expr) -> string {
    switch (expr) {
        Add(lhs, rhs): concatStrings(["(", expr2s(lhs), " + ", expr2s(rhs), ")"]);
        Sub(lhs, rhs): concatStrings(["(", expr2s(lhs), " - ", expr2s(rhs), ")"]);
        Mul(lhs, rhs): concatStrings(["(", expr2s(lhs), " * ", expr2s(rhs), ")"]);
        Div(lhs, rhs): concatStrings(["(", expr2s(lhs), " / ", expr2s(rhs), ")"]);
        Neg(value): concatStrings(["-", expr2s(value)]);
        Int(value): i2s(value);
        Var(name): name;
    }
}

s2rule(str: string) -> MatchRule {
    exprs = strSplit(str, "=");
    MatchRule(s2expr(exprs[0]), s2expr(exprs[1]))
}

exprEq(first: Expr, second: Expr) -> bool {
    eq = \e1, e2 -> exprEq(e1, e2);
    
    switch (first) {
        Add(lhs1, rhs1): {
            switch (second) {
                Add(lhs2, rhs2): eq(lhs1, lhs2) && eq(rhs1, rhs2);
                default: false;
            }
        }

        Sub(lhs1, rhs1): {
            switch (second) {
                Add(lhs2, rhs2): eq(lhs1, lhs2) && eq(rhs1, rhs2);
                default: false;
            }
        }

        Mul(lhs1, rhs1): {
            switch (second) {
                Add(lhs2, rhs2): eq(lhs1, lhs2) && eq(rhs1, rhs2);
                default: false;
            }
        }

        Div(lhs1, rhs1): {
            switch (second) {
                Add(lhs2, rhs2): eq(lhs1, lhs2) && eq(rhs1, rhs2);
                default: false;
            }
        }

        Neg(inner1): {
            switch (second) {
                Neg(inner2): eq(inner1, inner2);
                default: false;
            }
        }

        Int(value1): {
            switch (second) {
                Int(value2): value1 == value2;
                default: false;
            }
        }

        Var(name1): {
            switch (second) {
                Var(name2): name1 == name2;
                default: false;
            }
        }
    }
}

mergeVariableTrees(first: Tree<string, Expr>, second: Tree<string, Expr>) -> Maybe<Tree<string, Expr>> {
    variables = concat(tree2pairs(first), tree2pairs(second));

    foldM(
        variables,
        makeTree(),
        \tree, pair: Pair<string, Expr> -> {
            switch (lookupTree(tree, pair.first)) {
                Some(expr): {
                    if (exprEq(expr, pair.second)) {
                        Some(setTree(tree, pair.first, pair.second));
                    } else {
                        None();
                    }
                }

                None(): Some(setTree(tree, pair.first, pair.second));
            }
        }
    )
}

captureVariables(expr: Expr, before: Expr) -> Maybe<Tree<string, Expr>> {
    switch (before) {
        Var(name): Some(makeTree1(name, expr));

        Add(lhs2, rhs2): {
            switch (expr) {
                Add(lhs1, rhs1): {
                    left = captureVariables(lhs1, lhs2);
                    right = captureVariables(rhs1, rhs2);
                    maybeBind2(mergeVariableTrees)(left, right)
                }

                default: None();
            }
        }

        Sub(lhs2, rhs2): {
            switch (expr) {
                Sub(lhs1, rhs1): {
                    left = captureVariables(lhs1, lhs2);
                    right = captureVariables(rhs1, rhs2);
                    maybeBind2(mergeVariableTrees)(left, right)
                }

                default: None();
            }
        }

        Mul(lhs2, rhs2): {
            switch (expr) {
                Mul(lhs1, rhs1): {
                    left = captureVariables(lhs1, lhs2);
                    right = captureVariables(rhs1, rhs2);
                    maybeBind2(mergeVariableTrees)(left, right)
                }

                default: None();
            }
        }

        Div(lhs2, rhs2): {
            switch (expr) {
                Div(lhs1, rhs1): {
                    left = captureVariables(lhs1, lhs2);
                    right = captureVariables(rhs1, rhs2);
                    maybeBind2(mergeVariableTrees)(left, right)
                }

                default: None();
            }
        }

        Neg(inner2): {
            switch (expr) {
                Neg(inner1): {
                    captureVariables(inner1, inner2);
                }

                default: None();
            }
        }

        Int(value2): {
            switch (expr) {
                Int(value1): {
                    if (value1 == value2) {
                        Some(makeTree());
                    } else {
                        None();
                    }
                }

                default: None();
            }
        }
    }
}

applyVariables(after: Expr, vars: Tree<string, Expr>) -> Maybe<Expr> {
    apply = \e -> applyVariables(e, vars);
    
    switch (after) {
        Add(lhs, rhs): maybeMap2(\l, r -> Add(l, r))(apply(lhs), apply(rhs));
        Sub(lhs, rhs): maybeMap2(\l, r -> Sub(l, r))(apply(lhs), apply(rhs));
        Mul(lhs, rhs): maybeMap2(\l, r -> Mul(l, r))(apply(lhs), apply(rhs));
        Div(lhs, rhs): maybeMap2(\l, r -> Add(l, r))(apply(lhs), apply(rhs));
        Neg(inner): maybeMap(apply(inner), \i -> Neg(i));
        Int(value): Some(Int(value));
        Var(name): lookupTree(vars, name);
    }
}

captureAndApply(expr: Expr, rule: MatchRule) -> Maybe<Expr> {
    maybeBind(
        captureVariables(expr, rule.before),
        \vars -> applyVariables(rule.after, vars)
    )
}

transformBinop(lhs: Expr, rhs: Expr, f: (Expr, Expr) -> Expr, rules: [MatchRule]) -> Set<Expr> {
    left = transformExpression(lhs, rules);
    right = transformExpression(rhs, rules);

    foldSet(
        left,
        makeSet(),
        \result, e1 -> {
            mergeSets(
                result,
                mapSet(right, \e2 -> f(e1, e2))
            )
        }
    )
}

transformExpression(expr: Expr, rules: [MatchRule]) -> Set<Expr> {
    transform = \e -> transformExpression(expr, rules);

    fold(
        rules,
        makeSet(),
        \set, rule -> {
            new = switch (expr) {
                Add(lhs, rhs): transformBinop(lhs, rhs, \a, b -> Add(a, b), rules);
                Sub(lhs, rhs): transformBinop(lhs, rhs, \a, b -> Sub(a, b), rules);
                Mul(lhs, rhs): transformBinop(lhs, rhs, \a, b -> Mul(a, b), rules);
                Div(lhs, rhs): transformBinop(lhs, rhs, \a, b -> Div(a, b), rules);
                Neg(inner): mapSet(transform(inner), \e -> Neg(e));
                Int(value): makeSet1(Int(value));
                Var(name): makeSet1(Var(name));
            };

            new2 = switch (captureAndApply(expr, rule)) {
                Some(e): makeSet1(e);
                None(): makeSet();
            };

            new3 = makeSet1(expr);

            mergeSetsA([new, new2, new3])
        }
    )
}

main() {
    example = "(x + 0)";
    expr = s2expr(example);

    rules = map(
        [
            "(x + 0)=x",
            "(x * 1)=x",
            "(x * 0)=0",
            "(x / 1)=x",
            "(2 + 2)=4",
        ],
        s2rule
    );

    transformed = transformExpression(expr, rules);
    iteri(set2array(transformed), \idx, e -> println(i2s(idx + 1) + ". " + expr2s(e)));
}