import runtime;
import lingo/pegcode/driver;

Expr ::= Add, Sub, Mul, Div, Neg, Int, Var;
    Add(lhs: Expr, rhs: Expr);
    Sub(lhs: Expr, rhs: Expr);
    Mul(lhs: Expr, rhs: Expr);
    Div(lhs: Expr, rhs: Expr);
    Neg(expr: Expr);
    Int(value: int);
    Var(name: string);

// switch (expr) {
//     Add(lhs, rhs):
//     Sub(lhs, rhs):
//     Mul(lhs, rhs):
//     Div(lhs, rhs):
//     Neg(inner):
//     Int(value):
//     Var(name):
// }

Rule(before: Expr, after: Expr);

s2expr(str: string) -> Expr {
    grammar = compilePegGrammar("#include grammar.lingo");
    parsic(grammar, str, defaultPegActions);
}

expr2s(expr: Expr) -> string {
    switch (expr) {
        Add(lhs, rhs): concatStrings(["(", expr2s(lhs), " + ", expr2s(rhs), ")"]);
        Sub(lhs, rhs): concatStrings(["(", expr2s(lhs), " - ", expr2s(rhs), ")"]);
        Mul(lhs, rhs): concatStrings(["(", expr2s(lhs), " * ", expr2s(rhs), ")"]);
        Div(lhs, rhs): concatStrings(["(", expr2s(lhs), " / ", expr2s(rhs), ")"]);
        Neg(value): concatStrings(["-", expr2s(value)]);
        Int(value): i2s(value);
        Var(name): name;
    }
}

s2rule(str: string) -> Rule {
    exprs = strSplit(str, "=");
    Rule(s2expr(exprs[0]), s2expr(exprs[1]))
}

exprEq(first: Expr, second: Expr) -> bool {
    eq = \e -> exprEq(e);
    
    switch (first) {
        Add(lhs1, rhs1): {
            switch (second) {
                Add(lhs2, rhs2): eq(lhs1, lhs2) && eq(rhs1, rhs2);
                default: false;
            }
        }

        Sub(lhs1, rhs1): {
            switch (second) {
                Add(lhs2, rhs2): eq(lhs1, lhs2) && eq(rhs1, rhs2);
                default: false;
            }
        }

        Mul(lhs1, rhs1): {
            switch (second) {
                Add(lhs2, rhs2): eq(lhs1, lhs2) && eq(rhs1, rhs2);
                default: false;
            }
        }

        Div(lhs1, rhs1): {
            switch (second) {
                Add(lhs2, rhs2): eq(lhs1, lhs2) && eq(rhs1, rhs2);
                default: false;
            }
        }

        Neg(inner1): {
            switch (second) {
                Neg(inner2): eq(inner1, inner2);
                default: false;
            }
        }

        Int(value1): {
            switch (second) {
                Int(value2): value1 == value2;
                default: false;
            }
        }

        Var(name1): {
            switch (second) {
                Var(name2): name1 == name2;
                default: false;
            }
        }
    }
}

mergeVariableTrees(first: Tree<string, Expr>, second: Tree<string, Expr>) -> Maybe<Tree<string, Expr>> {
    variables = concat(tree2pairs(first), tree2pairs(second));

    foldM(
        variables,
        makeTree(),
        \tree, pair -> {
            switch (lookupTree(tree, pair.first)) {
                Some(expr): {
                    if (exprEq(expr, pair.second)) {
                        Some(setTree(tree, pair.first, pair.second));
                    } else {
                        None();
                    }
                }

                None(): Some(setTree(tree, pair.first, pair.second));
            }
        }
    )
}

captureVariables(expr: Expr, before: Expr) -> Maybe<Tree<string, Expr>> {
    switch (before) {
        Var(name): Some(makeTree1(name, expr));

        Add(lhs2, rhs2): {
            switch (expr) {
                Add(lhs1, rhs1): {
                    left = captureVariables(lhs1, lhs2);
                    right = captureVariables(rhs1, rhs2);
                    maybeBind2(mergeVariableTrees)(left, right)
                }

                default: None();
            }
        }

        Sub(lhs2, rhs2): {
            switch (expr) {
                Sub(lhs1, rhs1): {
                    left = captureVariables(lhs1, lhs2);
                    right = captureVariables(rhs1, rhs2);
                    maybeBind2(mergeVariableTrees)(left, right)
                }

                default: None();
            }
        }

        Mul(lhs2, rhs2): {
            switch (expr) {
                Mul(lhs1, rhs1): {
                    left = captureVariables(lhs1, lhs2);
                    right = captureVariables(rhs1, rhs2);
                    maybeBind2(mergeVariableTrees)(left, right)
                }

                default: None();
            }
        }

        Div(lhs2, rhs2): {
            switch (expr) {
                Div(lhs1, rhs1): {
                    left = captureVariables(lhs1, lhs2);
                    right = captureVariables(rhs1, rhs2);
                    maybeBind2(mergeVariableTrees)(left, right)
                }

                default: None();
            }
        }

        Neg(inner2): {
            switch (expr) {
                Neg(inner1): {
                    captureVariables(inner1, inner2);
                }

                default: None();
            }
        }

        Int(value2): {
            switch (expr) {
                Int(value1): {
                    if (value1 == value2) {
                        Some(makeTree());
                    } else {
                        None();
                    }
                }

                default: None();
            }
        }
    }
}

applyVariables(after: Expr, vars: Tree<string, int>) -> Maybe<Expr> {
    switch (expr) {
        Add(lhs, rhs): maybeMap2(\l, r -> Add(l, r))(applyVariables(lhs), applyVariables(rhs));
        Sub(lhs, rhs): maybeMap2(\l, r -> Sub(l, r))(applyVariables(lhs), applyVariables(rhs));
        Mul(lhs, rhs): maybeMap2(\l, r -> Mul(l, r))(applyVariables(lhs), applyVariables(rhs));
        Div(lhs, rhs): maybeMap2(\l, r -> Add(l, r))(applyVariables(lhs), applyVariables(rhs));
        Neg(inner): maybeMap(applyVariables(inner), \i -> Neg(i));
        Int(value): Some(Int(value));
        Var(name): lookupTree(vars, name);
    }
}

transformExpression(expr: Expr, rules: [Rule]) -> Set<Expr> {

}

main() {
    example = "(((y * (x + y)) * ((x - 1) / (1 / y))) * ((z + 1) / (z + 2)))";
    expr = s2expr(example);

    rules = map(
        [
            "(x + 0) = x",
            "(x * 1) = x",
            "(x * 0) = 0",
            "(x / 1) = x",
            "(2 + 2) = 4",
        ],
        s2rule
    );

    transformed = transformExpression(expr, rules);
    iteri(set2array(transformed), \idx, expr -> println(i2s(idx + 1) + ". " + expr2s(expr)));
}