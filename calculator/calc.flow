import runtime;
import lingo/pegcode/driver;

Rational(num: int, denom: int);

Expr ::= Add, Sub, Mul, Div, Neg, Int, Var;
    Add(lhs: Expr, rhs: Expr);
    Sub(lhs: Expr, rhs: Expr);
    Mul(lhs: Expr, rhs: Expr);
    Div(lhs: Expr, rhs: Expr);
    Neg(expr: Expr);
    Int(value: int);
    Var(name: string);

s2expr(str: string) -> Expr {
    grammar = compilePegGrammar("#include grammar.lingo");
    parsic(grammar, str, defaultPegActions);
}

expr2s(expr: Expr) -> string {
    switch (expr) {
        Add(lhs, rhs): concatStrings(["(", expr2s(lhs), " + ", expr2s(rhs), ")"]);
        Sub(lhs, rhs): concatStrings(["(", expr2s(lhs), " - ", expr2s(rhs), ")"]);
        Mul(lhs, rhs): concatStrings(["(", expr2s(lhs), " * ", expr2s(rhs), ")"]);
        Div(lhs, rhs): concatStrings(["(", expr2s(lhs), " / ", expr2s(rhs), ")"]);
        Neg(value): concatStrings(["-", expr2s(value)]);
        Int(value): i2s(value);
        Var(name): name;
    }
}

Term(vars: Tree<string, int> /* key = variable name, value = exponent */ );

mulTerms(lhs: Term, rhs: Term) -> Term {
    Term(
        mergeTreeCustom(
            lhs.vars, rhs.vars, \_, e1, e2 -> e1 + e2
        )
    )
}

Polynom(terms: Tree<Term, int> /* key = term, value = integer coefficient */ );

negPolynom(polynom: Polynom) -> Polynom {
    Polynom(
        mapTree(
            polynom.terms, \coeff -> -coeff,
        )
    )
}

addPolynoms(lhs: Polynom, rhs: Polynom) -> Polynom {
    Polynom(
        mergeTreeCustom(
            lhs.terms, rhs.terms, \_, c1, c2 -> c1 + c2
        )
    )
}

subPolynoms(lhs: Polynom, rhs: Polynom) -> Polynom {
    addPolynoms(lhs, negPolynom(rhs))
}

mulPolynoms(lhs: Polynom, rhs: Polynom) -> Polynom {
    foldTree(
        lhs.terms,
        Polynom(makeTree()),
        \term, coeff, result -> {
            mul = Polynom(
                foldTree(
                    rhs.terms,
                    makeTree(),
                    \t, c, res -> {
                        setTree(res, mulTerms(term, t), coeff * c)
                    }
                )
            );

            addPolynoms(mul, result)
        }
    )
}

polynom2s(polynom: Polynom) -> string {
    foldTree(
        polynom.terms,
        "",
        \term, coeff, result -> {
            term_s = foldTree(
                term.vars,
                "",
                \var, exp, s -> s + var + "^" + i2s(exp) 
            );

            if (result == "") {
                i2s(coeff) + term_s
            } else {
                if (coeff > 0) {
                    result + " + " + i2s(coeff) + term_s
                } else {
                    result + " - " + i2s(-coeff) + term_s
                }
            }
        }
    )
}

toRationalForm(expr: Expr) -> Expr {
    switch (expr) {
        Add(lhs, rhs): {
            left = toRationalForm(lhs);
            right = toRationalForm(rhs);

            switch (left) {
                Div(a, b): {
                    switch (right) {
                        Div(c, d): Div(Add(Mul(a, d), Mul(c, b)), Mul(b, d)); 
                        default: Div(Add(a, Mul(b, right)), b);
                    }
                };

                default: {
                    switch (right) {
                        Div(a, b): Div(Add(Mul(left, b), a), b); 
                        default: Add(left, right);
                    }
                };
            }
        };

        Sub(lhs, rhs): {
            left = toRationalForm(lhs);
            right = toRationalForm(rhs);

            switch (left) {
                Div(a, b): {
                    switch (right) {
                        Div(c, d): Div(Sub(Mul(a, d), Mul(c, b)), Mul(b, d)); 
                        default: Div(Sub(a, Mul(b, right)), b);
                    }
                };

                default: {
                    switch (right) {
                        Div(a, b): Div(Sub(Mul(left, b), a), b); 
                        default: Sub(left, right);
                    }
                };
            }
        };

        Mul(lhs, rhs): {
            left = toRationalForm(lhs);
            right = toRationalForm(rhs);

            switch (left) {
                Div(a, b): {
                    switch (right) {
                        Div(c, d): Div(Mul(a, c), Mul(b, d));
                        default: Div(Mul(a, right), b);
                    }
                };

                default: {
                    switch (right) {
                        Div(a, b): Div(Mul(left, a), b);
                        default: Mul(left, right);
                    }
                };
            }
        };

        Div(lhs, rhs): {
            left = toRationalForm(lhs);
            right = toRationalForm(rhs);

            switch (left) {
                Div(a, b): {
                    switch (right) {
                        Div(c, d): Div(Mul(a, d), Mul(b, c));
                        default: Div(a, Mul(b, right));
                    }
                };

                default: {
                    switch (right) {
                        Div(a, b): Div(Mul(left, b), a);
                        default: Div(left, right);
                    }
                };
            }
        }

        Neg(inner): {
            e = toRationalForm(inner);

            switch (e) {
                Div(a, b): Div(Neg(a), b);
                default: Neg(e);
            }
        };

        Int(value): Div(Int(value), Int(1));
        Var(name): Div(Var(name), Int(1));
    }
}

main() {
    example = "(-( ((x - 1) / (x - 2)) * (1 / ((x - 1) / (x - 3))) ))";
    expr = s2expr(example);
    rational = toRationalForm(expr);
    simplified = simplifyExpression(rational);
    println(expr2s(simplified));
}