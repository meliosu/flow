import runtime;
import lingo/pegcode/driver;

Rational(num: int, denom: int);

simplify(value: Rational) -> Rational {
    div = gcd(value.num, value.denom);
    new = Rational(value.num / div, value.denom / div);
    if (new.denom > 0) {
        new
    } else {
        Rational(-new.num, -new.denom)
    }
}

r2s(rational: Rational) -> string {
    i2s(rational.num) + "/" + i2s(rational.denom)
}

Expr ::= Add, Sub, Mul, Div, Neg, Int, Var;
    Add(lhs: Expr, rhs: Expr);
    Sub(lhs: Expr, rhs: Expr);
    Mul(lhs: Expr, rhs: Expr);
    Div(lhs: Expr, rhs: Expr);
    Neg(value: Expr);
    Int(value: int);
    Var(name: string);
    
s2expr(str: string) -> Expr {
    grammar = compilePegGrammar("#include grammar.lingo");
    parsic(grammar, str, defaultPegActions);
}

maybeAdd(lhs: Maybe<Rational>, rhs: Maybe<Rational>) -> Maybe<Rational> {
    maybeMap2(\left, right -> {
        Rational(left.num * right.denom + right.num * left.denom, left.denom * right.denom)
    })(lhs, rhs)
}

maybeSub(lhs: Maybe<Rational>, rhs: Maybe<Rational>) -> Maybe<Rational> {
    maybeMap2(\left, right -> {
        Rational(left.num * right.denom - right.num * left.denom, left.denom * right.denom)
    })(lhs, rhs)
}

maybeMul(lhs: Maybe<Rational>, rhs: Maybe<Rational>) -> Maybe<Rational> {
    maybeMap2(\left, right -> {
        Rational(left.num * right.num, left.denom * right.denom)
    })(lhs, rhs)
}

maybeDiv(lhs: Maybe<Rational>, rhs: Maybe<Rational>) -> Maybe<Rational> {
    if (eitherMap(rhs, \r -> r.num == 0, false)) {
        None();
    } else {
        maybeMap2(\left, right -> {
            Rational(left.num * right.denom, left.denom * right.num);
        })(lhs, rhs);
    }
}

maybeNeg(value: Maybe<Rational>) -> Maybe<Rational> {
    maybeMap(value, \v -> Rational(-v.num, v.denom))
}

expr2r(expr: Expr, variables: Tree<string, Rational>) -> Maybe<Rational> {
    switch (expr) {
        Add(lhs, rhs): maybeAdd(expr2r(lhs, variables), expr2r(rhs, variables));
        Sub(lhs, rhs): maybeSub(expr2r(lhs, variables), expr2r(rhs, variables));
        Mul(lhs, rhs): maybeMul(expr2r(lhs, variables), expr2r(rhs, variables));
        Div(lhs, rhs): maybeDiv(expr2r(lhs, variables), expr2r(rhs, variables));
        Neg(value): maybeNeg(expr2r(value, variables));
        Int(value): Some(Rational(value, 1));
        Var(name): lookupTree(variables, name);
    }
}

main() {
    vars = fold([
        Pair("xyz4", Rational(3, 1)),
        Pair("ab3_c", Rational(3, 2)),
    ], makeTree(), \tree, p -> setTree(tree, p.first, p.second));

    example = "(((xyz4 + 2) - (5 / 2)) / ((-ab3_c) + (1 / 2)))";
    expr = s2expr(example);
    println(expr);
    result = expr2r(expr, vars);
    
    switch (result) {
        Some(rational): println(r2s(simplify(rational)));
        None(): println("Error");
    }
}