import runtime;
import lingo/pegcode/driver;
import ds/arrayutils;

Expr ::= Add, Sub, Mul, Div, Neg, Int, Var;
    Add(lhs: Expr, rhs: Expr);
    Sub(lhs: Expr, rhs: Expr);
    Mul(lhs: Expr, rhs: Expr);
    Div(lhs: Expr, rhs: Expr);
    Neg(expr: Expr);
    Int(value: int);
    Var(name: string);

MatchRule(before: Expr, after: Expr);

s2expr(str: string) -> Expr {
    grammar = compilePegGrammar("#include grammar.lingo");
    parsic(grammar, str, defaultPegActions);
}

expr2s(expr: Expr) -> string {
    switch (expr) {
        Add(lhs, rhs): concatStrings(["(", expr2s(lhs), " + ", expr2s(rhs), ")"]);
        Sub(lhs, rhs): concatStrings(["(", expr2s(lhs), " - ", expr2s(rhs), ")"]);
        Mul(lhs, rhs): concatStrings(["(", expr2s(lhs), " * ", expr2s(rhs), ")"]);
        Div(lhs, rhs): concatStrings(["(", expr2s(lhs), " / ", expr2s(rhs), ")"]);
        Neg(value): concatStrings(["-", expr2s(value)]);
        Int(value): i2s(value);
        Var(name): name;
    }
}

s2rule(str: string) -> MatchRule {
    exprs = strSplit(str, "=");
    MatchRule(s2expr(exprs[0]), s2expr(exprs[1]))
}

applyRule(expr: Expr, rule: MatchRule) -> Maybe<Expr> {
    if (expr == rule.before) {
        Some(rule.after)
    } else {
        None()
    }
}

transformBinop(lhs: Expr, rhs: Expr, f: (Expr, Expr) -> Expr, rules: [MatchRule]) -> Set<Expr> {
    transformed_lhs = transformExpression(lhs, rules);
    transformed_rhs = transformExpression(rhs, rules);

    foldSet(
        transformed_lhs,
        makeSet(),
        \set, e1 -> {
            mergeSets(
                set,
                mapSet(
                    transformed_rhs,
                    \e2 -> f(e1, e2)
                )
            )
        } 
    )
}

transformExpression(expr: Expr, rules: [MatchRule]) -> Set<Expr> {
    new1 = switch (expr) {
        Add(lhs, rhs): transformBinop(lhs, rhs, \l, r -> Add(l, r), rules);
        Sub(lhs, rhs): transformBinop(lhs, rhs, \l, r -> Sub(l, r), rules);
        Mul(lhs, rhs): transformBinop(lhs, rhs, \l, r -> Mul(l, r), rules);
        Div(lhs, rhs): transformBinop(lhs, rhs, \l, r -> Div(l, r), rules);
        Neg(inner): mapSet(transformExpression(inner, rules), \e -> Neg(e));
        Int(value): makeSet1(Int(value));
        Var(name): makeSet1(Var(name));
    };

    new2 = fold(
        rules,
        makeSet(),
        \set, rule -> {
            mergeSets(
                set,
                foldSet(
                    new1,
                    makeSet(),
                    \subset, e -> {
                        switch (applyRule(e, rule)) {
                            Some(transformed): insertSet(subset, transformed);
                            None(): subset;
                        }
                    }
                )
            )
        }
    );

    mergeSets(new1, new2)
}

main() {
    example = "((x + (2 / q)) + ((1 + 1) + (7 * (w + 1))))";
    expr = s2expr(example);
    rules = map(
        [
            "(x + (2 / q)) = a",
            "(a + z) = b",
            "(2 + u) = z",
            "(7 * (w + 1)) = u",
            "(1 + 1) = 2",
        ],
        s2rule
    );

    transformed = transformExpression(expr, rules);
    iteri(set2array(transformed), \idx, e -> println(i2s(idx + 1) + ". " + expr2s(e)));
}