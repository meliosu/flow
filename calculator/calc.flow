import runtime;
import lingo/pegcode/driver;
import ds/arrayutils;

Expr ::= Add, Sub, Mul, Div, Neg, Int, Var;
    Add(lhs: Expr, rhs: Expr);
    Sub(lhs: Expr, rhs: Expr);
    Mul(lhs: Expr, rhs: Expr);
    Div(lhs: Expr, rhs: Expr);
    Neg(expr: Expr);
    Int(value: int);
    Var(name: string);

MatchRule(before: Expr, after: Expr);

s2expr(str: string) -> Expr {
    grammar = compilePegGrammar("#include grammar.lingo");
    parsic(grammar, str, defaultPegActions);
}

expr2s(expr: Expr) -> string {
    switch (expr) {
        Add(lhs, rhs): concatStrings(["(", expr2s(lhs), " + ", expr2s(rhs), ")"]);
        Sub(lhs, rhs): concatStrings(["(", expr2s(lhs), " - ", expr2s(rhs), ")"]);
        Mul(lhs, rhs): concatStrings(["(", expr2s(lhs), " * ", expr2s(rhs), ")"]);
        Div(lhs, rhs): concatStrings(["(", expr2s(lhs), " / ", expr2s(rhs), ")"]);
        Neg(value): concatStrings(["-", expr2s(value)]);
        Int(value): i2s(value);
        Var(name): name;
    }
}

s2rule(str: string) -> MatchRule {
    exprs = strSplit(str, "=");
    MatchRule(s2expr(exprs[0]), s2expr(exprs[1]))
}

exprDepth(expr: Expr) -> int {
    binop = \l, r -> max(exprDepth(l), exprDepth(r));
    
    1 + switch (expr) {
        Add(lhs, rhs): binop(lhs, rhs);
        Sub(lhs, rhs): binop(lhs, rhs);
        Mul(lhs, rhs): binop(lhs, rhs);
        Div(lhs, rhs): binop(lhs, rhs);
        Neg(inner): exprDepth(inner);
        Int(value): 0;
        Var(name): 0;
    }
}

applyRule(expr: Expr, rule: MatchRule) -> Maybe<Expr> {
    if (expr == rule.before) {
        Some(rule.after)
    } else {
        None()
    }
}

transformBinop(lhs: Expr, rhs: Expr, f: (Expr, Expr) -> Expr, rules: [MatchRule]) -> Set<Expr> {
    transformed_lhs = transformExpression(lhs, rules);
    transformed_rhs = transformExpression(rhs, rules);

    foldSet(
        transformed_lhs,
        makeSet(),
        \set, e1 -> {
            mergeSets(
                set,
                mapSet(
                    transformed_rhs,
                    \e2 -> f(e1, e2)
                )
            )
        } 
    )
}

transformExpression(expr: Expr, rules: [MatchRule]) -> Set<Expr> {
    new1 = switch (expr) {
        Add(lhs, rhs): transformBinop(lhs, rhs, \l, r -> Add(l, r), rules);
        Sub(lhs, rhs): transformBinop(lhs, rhs, \l, r -> Sub(l, r), rules);
        Mul(lhs, rhs): transformBinop(lhs, rhs, \l, r -> Mul(l, r), rules);
        Div(lhs, rhs): transformBinop(lhs, rhs, \l, r -> Div(l, r), rules);
        Neg(inner): mapSet(transformExpression(inner, rules), \e -> Neg(e));
        Int(value): makeSet1(Int(value));
        Var(name): makeSet1(Var(name));
    };

    new2 = fold(
        rules,
        makeSet(),
        \set, rule -> {
            mergeSets(
                set,
                foldSet(
                    new1,
                    makeSet(),
                    \subset, e -> {
                        switch (applyRule(e, rule)) {
                            Some(transformed): insertSet(subset, transformed);
                            None(): subset;
                        }
                    }
                )
            )
        }
    );

    mergeSets(new1, new2)
}

pickBest(expressions: Set<Expr>) -> Expr {
    sortCustom(
        set2array(expressions),
        \e -> exprDepth(e),
        true
    )[0]
}

main() {
    examples = [
        Pair("(x + y)", ["(x + y) = z"]),
        Pair("((w * z) - 1)", ["a = b", "(w * z) = u"]),
        Pair("(a + b)", []),
        Pair("(u + w)", ["u = x", "w = y", "(x + y) = z"]),
        Pair("((x + (2 / q)) + ((1 + 1) + (7 * (w + 1))))", [
            "(7 * (w + 1)) = u",
            "(1 + 1) = 2",
            "(a + z) = b",
            "(x + (2 / q)) = a",
            "(2 + u) = z",
        ]),
    ];

    iter(
        examples,
        \pair -> {
            expr = s2expr(pair.first);
            rules = map(pair.second, s2rule);
            transformed = transformExpression(expr, rules);
            println("Transforming " + expr2s(expr));
            iteri(set2array(transformed), \idx, e -> println(i2s(idx + 1) + ". " + expr2s(e)));
            println("Most simplified: " + expr2s(pickBest(transformed)) + "\n");
        }
    );
}