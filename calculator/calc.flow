import runtime;
import lingo/pegcode/driver;

Expr ::= Add, Sub, Mul, Div, Neg, Int, Var;
    Add(lhs: Expr, rhs: Expr);
    Sub(lhs: Expr, rhs: Expr);
    Mul(lhs: Expr, rhs: Expr);
    Div(lhs: Expr, rhs: Expr);
    Neg(expr: Expr);
    Int(value: int);
    Var(name: string);

PTerm(vars: Tree<string, int> /* key = variable name, value = exponent */ );

Polynom(terms: Tree<PTerm, int> /* key = term, value = integer coefficient */ );

s2expr(str: string) -> Expr {
    grammar = compilePegGrammar("#include grammar.lingo");
    parsic(grammar, str, defaultPegActions);
}

expr2s(expr: Expr) -> string {
    switch (expr) {
        Add(lhs, rhs): concatStrings(["(", expr2s(lhs), " + ", expr2s(rhs), ")"]);
        Sub(lhs, rhs): concatStrings(["(", expr2s(lhs), " - ", expr2s(rhs), ")"]);
        Mul(lhs, rhs): concatStrings(["(", expr2s(lhs), " * ", expr2s(rhs), ")"]);
        Div(lhs, rhs): concatStrings(["(", expr2s(lhs), " / ", expr2s(rhs), ")"]);
        Neg(value): concatStrings(["-", expr2s(value)]);
        Int(value): i2s(value);
        Var(name): name;
    }
}

mulTerms(lhs: PTerm, rhs: PTerm) -> PTerm {
    PTerm(
        mergeTreeCustom(
            lhs.vars, rhs.vars, \_, e1, e2 -> e1 + e2
        )
    )
}

negPolynom(polynom: Polynom) -> Polynom {
    Polynom(
        mapTree(
            polynom.terms, \coeff -> -coeff,
        )
    )
}

addPolynoms(lhs: Polynom, rhs: Polynom) -> Polynom {
    Polynom(
        filterTree(
            mergeTreeCustom(
                lhs.terms, rhs.terms, \_, c1, c2 -> c1 + c2
            ),
            \term, coeff -> coeff != 0
        )
    )
}

subPolynoms(lhs: Polynom, rhs: Polynom) -> Polynom {
    addPolynoms(lhs, negPolynom(rhs))
}

mulPolynoms(lhs: Polynom, rhs: Polynom) -> Polynom {
    foldTree(
        lhs.terms,
        Polynom(makeTree()),
        \term, coeff, result -> {
            mul = Polynom(
                foldTree(
                    rhs.terms,
                    makeTree(),
                    \t, c, res -> {
                        setTree(res, mulTerms(term, t), coeff * c)
                    }
                )
            );

            addPolynoms(mul, result)
        }
    )
}

polynom2s(polynom: Polynom) -> string {
    foldTree(
        polynom.terms,
        "",
        \term, coeff, result -> {
            term_s = foldTree(
                term.vars,
                "",
                \var, exp, s -> {
                    s + if (exp == 1) {
                        var
                    } else {
                        var + "^" + i2s(exp)
                    }
                }
            );

            result + if (result == "") {
                if (coeff == 1) {
                    term_s
                } else if (coeff == -1) {
                    "-" + term_s
                } else {
                    i2s(coeff) + term_s
                }
            } else {
                if (coeff == 1) {
                    " + " + term_s
                } else if (coeff == -1) {
                    " - " + term_s
                } else if (coeff > 0) {
                    " + " + i2s(coeff) + term_s
                } else {
                    " - " + i2s(-coeff) + term_s
                }
            }
        }
    )
}

expr2polynom(expr: Expr) -> Polynom {
    switch (expr) {
        Add(lhs, rhs): addPolynoms(expr2polynom(lhs), expr2polynom(rhs));
        Sub(lhs, rhs): subPolynoms(expr2polynom(lhs), expr2polynom(rhs));
        Mul(lhs, rhs): mulPolynoms(expr2polynom(lhs), expr2polynom(rhs));
        Div(lhs, rhs): Polynom(makeTree()); 
        Neg(inner): negPolynom(expr2polynom(inner));
        Int(value): {
            term = PTerm(makeTree());
            Polynom(setTree(makeTree(), term, value))
        }

        Var(name): {
            term = PTerm(setTree(makeTree(), name, 1));
            Polynom(setTree(makeTree(), term, 1))
        }
    }
}

toRationalForm(expr: Expr) -> Div {
    switch (expr) {
        Add(lhs, rhs): {
            left = toRationalForm(lhs);
            right = toRationalForm(rhs);
            Div(Add(Mul(left.lhs, right.rhs), Mul(left.rhs, right.lhs)), Mul(left.rhs, right.rhs))
        }

        Sub(lhs, rhs): {
            left = toRationalForm(lhs);
            right = toRationalForm(rhs);
            Div(Sub(Mul(left.lhs, right.rhs), Mul(left.rhs, right.lhs)), Mul(left.rhs, right.rhs))
        }

        Mul(lhs, rhs): {
            left = toRationalForm(lhs);
            right = toRationalForm(rhs);
            Div(Mul(left.lhs, right.lhs), Mul(left.rhs, right.rhs))
        }

        Div(lhs, rhs): {
            left = toRationalForm(lhs);
            right = toRationalForm(rhs);
            Div(Mul(left.lhs, right.rhs), Mul(left.rhs, right.lhs))
        }

        Neg(inner): {
            r = toRationalForm(inner);
            Div(Neg(r.lhs), r.rhs)
        }

        Int(value): Div(Int(value), Int(1));
        Var(name): Div(Var(name), Int(1));
    }
}

main() {
    example = "(((y * (x + y)) * ((x - 1) / (1 / y))) * ((z + 1) / (z + 2)))";
    expr = s2expr(example);
    rational = toRationalForm(expr);
    println("(" + polynom2s(expr2polynom(rational.lhs)) + ") / (" + polynom2s(expr2polynom(rational.rhs)) + ")");
}