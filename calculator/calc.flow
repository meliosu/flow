import runtime;
import lingo/pegcode/driver;

Rational(num: int, denom: int);

simplifyRational(value: Rational) -> Rational {
    div = gcd(value.num, value.denom);
    new = Rational(value.num / div, value.denom / div);
    if (new.denom > 0) {
        new
    } else {
        Rational(-new.num, -new.denom)
    }
}

r2s(rational: Rational) -> string {
    i2s(rational.num) + "/" + i2s(rational.denom)
}

Expr ::= Add, Sub, Mul, Div, Neg, Int, Var;
    Add(lhs: Expr, rhs: Expr);
    Sub(lhs: Expr, rhs: Expr);
    Mul(lhs: Expr, rhs: Expr);
    Div(lhs: Expr, rhs: Expr);
    Neg(expr: Expr);
    Int(value: int);
    Var(name: string);
    
s2expr(str: string) -> Expr {
    grammar = compilePegGrammar("#include grammar.lingo");
    parsic(grammar, str, defaultPegActions);
}

expr2s(expr: Expr) -> string {
    switch (expr) {
        Add(lhs, rhs): concatStrings(["(", expr2s(lhs), " + ", expr2s(rhs), ")"]);
        Sub(lhs, rhs): concatStrings(["(", expr2s(lhs), " - ", expr2s(rhs), ")"]);
        Mul(lhs, rhs): concatStrings(["(", expr2s(lhs), " * ", expr2s(rhs), ")"]);
        Div(lhs, rhs): concatStrings(["(", expr2s(lhs), " / ", expr2s(rhs), ")"]);
        Neg(value): concatStrings(["-", expr2s(value)]);
        Int(value): i2s(value);
        Var(name): name;
    }
}

maybeAdd(lhs: Maybe<Rational>, rhs: Maybe<Rational>) -> Maybe<Rational> {
    maybeMap2(\left, right -> {
        denom = lcm(left.denom, right.denom);
        Rational(left.num * (denom / left.denom) + right.num * (denom / right.denom), denom)
    })(lhs, rhs)
}

maybeSub(lhs: Maybe<Rational>, rhs: Maybe<Rational>) -> Maybe<Rational> {
    maybeAdd(lhs, maybeMap(rhs, \v -> Rational(-v.num, v.denom)))
}

maybeMul(lhs: Maybe<Rational>, rhs: Maybe<Rational>) -> Maybe<Rational> {
    maybeMap2(\left, right -> {
        left_m = gcd(left.num, right.denom);
        right_m = gcd(left.denom, right.num);
        Rational((left.num / left_m) * (right.num / right_m), (left.denom / left_m) * (right.denom / right_m))
    })(lhs, rhs)
}

maybeDiv(lhs: Maybe<Rational>, rhs: Maybe<Rational>) -> Maybe<Rational> {
    if (eitherMap(rhs, \r -> r.num == 0, false)) {
        None();
    } else {
        maybeMul(lhs, maybeMap(rhs, \v -> Rational(v.denom, v.num)));
    }
}

maybeNeg(value: Maybe<Rational>) -> Maybe<Rational> {
    maybeMap(value, \v -> Rational(-v.num, v.denom))
}

expr2r(expr: Expr, variables: Tree<string, Rational>) -> Maybe<Rational> {
    switch (expr) {
        Add(lhs, rhs): maybeAdd(expr2r(lhs, variables), expr2r(rhs, variables));
        Sub(lhs, rhs): maybeSub(expr2r(lhs, variables), expr2r(rhs, variables));
        Mul(lhs, rhs): maybeMul(expr2r(lhs, variables), expr2r(rhs, variables));
        Div(lhs, rhs): maybeDiv(expr2r(lhs, variables), expr2r(rhs, variables));
        Neg(value): maybeNeg(expr2r(value, variables));
        Int(value): Some(Rational(value, 1));
        Var(name): lookupTree(variables, name);
    }
}

differentiate(expr: Expr, var: string) -> Expr {
    diff = \e -> differentiate(e, var);
    
    switch (expr) {
        Add(lhs, rhs): Add(diff(lhs), diff(rhs));
        Sub(lhs, rhs): Sub(diff(lhs), diff(rhs));
        Mul(lhs, rhs): Add(Mul(diff(lhs), rhs), Mul(lhs, diff(rhs)));
        Div(lhs, rhs): Div(Sub(Mul(diff(lhs), rhs), Mul(lhs, diff(rhs))), Mul(rhs, rhs));
        Neg(value): Neg(diff(value));
        Int(value): Int(0);
        Var(name): if (name == var) { Int(1) } else { Int(0) };
    }
}

simplifyExpression(expr: Expr) -> Expr {
    simplify = \e -> simplifyExpression(e);

    switch (expr) {
        Add(lhs, rhs): {
            left = simplify(lhs);
            right = simplify(rhs);

            if (left == Int(0)) {
                right
            } else if (right == Int(0)) {
                left
            } else {
                Add(left, right)
            }
        }

        Sub(lhs, rhs): {
            left = simplify(lhs);
            right = simplify(rhs);

            if (left == Int(0)) {
                simplify(Neg(left))
            } else if (right == Int(0)) {
                left
            } else {
                Sub(left, right)
            }
        }

        Mul(lhs, rhs): {
            left = simplify(lhs);
            right = simplify(rhs);

            if (left == Int(0) || right == Int(0)) {
                Int(0)
            } else if (left == Int(1)) {
                right
            } else if (right == Int(1)) {
                left
            } else {
                Mul(left, right)
            }
        }

        Div(lhs, rhs): {
            left = simplify(lhs);
            right = simplify(rhs);

            if (left == Int(0)) {
                Int(0)
            } else if (right == Int(1)) {
                left
            } else {
                Div(left, right)
            }
        }

        Neg(value): {
            switch (value) {
                Neg(inner): simplify(inner);
                Int(number): if (number == 0) { Int(0) } else { Neg(Int(number)) };
                default: Neg(simplify(value));
            }
        }

        Int(value): Int(value);
        Var(name): Var(name);
    }
}

toRationalForm(expr: Expr) -> Expr {
    switch (expr) {
        Add(lhs, rhs): {
            left = toRationalForm(lhs);
            right = toRationalForm(rhs);

            switch (left) {
                Div(a, b): {
                    switch (right) {
                        Div(c, d): Div(Add(Mul(a, d), Mul(c, b)), Mul(b, d)); 
                        default: Div(Add(a, Mul(b, right)), b);
                    }
                };

                default: ;
            }
        };

        Sub(lhs, rhs): {

        };


        Mul(lhs, rhs): {
            left = toRationalForm(lhs);
            right = toRationalForm(rhs);

            switch (left) {
                Div(a, b): {
                    switch (right) {
                        Div(c, d): Div(Mul(a, c), Mul(b, d));
                        default: ;
                    }
                };

                default: {
                    switch (right) {
                        Div(a, b): ;
                        default: Mul(left, right);
                    }
                }
            }
        };

        Div(lhs, rhs): {
            left = toRationalForm(lhs);
            right = toRationalForm(rhs);

            switch (left) {
                Div(a, b): {
                    switch (right) {
                        Div(c, d): Div(Mul(a, d), Mul(b, c));
                        default: Div(a, Mul(b, right));
                    }
                };

                default: {
                    switch (right) {
                        Div(a, b): Div(Mul(b, right), a);
                        default: Div(left, right);
                    }
                };
            }
        }

        Neg(expr): {
            e = toRationalForm(expr);

            switch (e) {
                Div(a, b): Div(Neg(a), b);
                default: Neg(e);
            }
        };

        Int(value): Int(value);
        Var(name): Var(name);
    }
}

main() {
    example = "((x * x) * (y * y))";
    expr = s2expr(example);
    derivative = differentiate(expr, "x");
    simplified = simplifyExpression(derivative);
    println(expr2s(derivative));
    println(expr2s(simplified));
}